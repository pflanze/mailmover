#!/usr/bin/perl -wT
# ^- risk T  starting from Sun, 24 Oct 2004 22:50:45 +0200


# Sam Nov 29 23:17:06 MET 2003
(my $email='pflanze%gmx,ch')=~ tr/%,/@./;

use strict;

use constant catcherrors=>1;# true= exceptions and warnings are catched/collected and delivered by mail -> turn off for debugging.
# but do this anyway:
use Carp;
$SIG{__DIE__}= sub {
    if (ref($_[0])) {
	# ok
	die @_;
    } else {
	confess @_;
    }
};
use Scalar::Util 'tainted';

use Chj::xopendir;
use Chj::xperlfunc 'xlinkunlink';
my $do_send_autoreply;
BEGIN{
    $do_send_autoreply=0;#

    require "/root/bin/mailmoverlib.pm";
    require "/root/bin/mailmover_autoreply.pm" if $do_send_autoreply;
}
use elcms_general_settings;
use EL::Util::Sendmail;
use Chj::Maildir::Basefolder;
use Chj::xtmpfile;
use Chj::singlequote;
use Chj::chompspace;
use Chj::Path::Truncator::MD5;

# wann will ich eigentlich msgid recorden wirklich?, wann will ich double elimination/checks? normalerweise ja nicht?. (doubleelim bloss wenn sie im gleichen folder landen).(NA oder  wenn notiz und das doppel beide im infolder landen dann auch, oder?, oder notiz unterdrucken dann? eh isch jo eh unterdrückt dann. na, aber dann später wenn die reply aus ml eintrifft, DANN die notiz unterdrücken wär was)

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname -d sourcedir | -f sourcefile(s)  targetbase

  Options:
  -d|--dir  path      sourcedir
  --leave-inbox       xxx
  -l|--loop-every n   keep running: sleep n seconds then scan again.
  --repeat n          only loop n times, then end. (to prevent memoryleaks from becoming awful, or for test runs with Devel::LeakTrace)

  (Christian Jaeger <$email>)
";
exit @_ ? 1 : 0;
}

my @args;
my $DEBUG=0;
my $verbose=0;
my ($sourcedir);
my ($opt_leaveinbox,$opt_loop,$opt_repeat);
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
    	usage
    } elsif ($_ eq '--') {
    	push @args, @ARGV[$i+1..$#ARGV];
    	last;
    } elsif (/^--?d(?:dir(?:=(.*))?)?$/) {
        if (defined $1) {
            $sourcedir=$1
        } else {
            $sourcedir=$ARGV[++$i] or usage "missing argument for '$_' option";
        }
    } elsif (/^--?l(?:oop-every(?:=(.*))?)?$/) {
        if (defined $1) {
            $opt_loop=$1
        } else {
            $opt_loop=$ARGV[++$i]
        }
	$opt_loop+=0;
	$opt_loop or usage "missing argument for '$_' option";
    } elsif (/^--?d(ebug)?$/) {
	$DEBUG=1;
    } elsif (/^--leave-inbox$/) {
	$opt_leaveinbox=1;
    } elsif (/^--repeat(?:=(.*))?$/) {
        if (defined $1) {
            $opt_repeat=$1
        } else {
            $opt_repeat=$ARGV[++$i]
        }
	$opt_loop+=0;
	$opt_loop or usage "missing argument for '$_' option";
    } elsif (/^--?(v+)(?:erbose)?$/) {
	$verbose+=length($1);
    } elsif (/^-./) {
    	usage("Unknown option '$_'\n");
    } else {
    	push @args, $_
    }
}
usage unless @args;
usage "--repeat requires --loop-every" if $opt_repeat and not $opt_loop;

my $targetbase= do {
    my $p= pop @args;
    # detaint it - trust it.
    $p=~ m|^([^~].*)|s or die "invalid path starting with a tilde: '$p'";
    $1
};

my $truncator= Chj::Path::Truncator::MD5->new($targetbase,3);

my @warns;
#my $warnsubject="warnings"; nein eben doch separate.

if (catcherrors) {
    $SIG{__WARN__}=sub{push @warns,"Warning:\n".(Carp::longmess @_)};
}

{
    # deliver warn mail. one per mailmover call also. im gegensatz zu chris wo eins per email.

    #my $base= Chj::Maildir::Basefolder->new($targetbase);#tja
    #schittttt, stimmt nödmal, Maildir/filtered
    my $bebebase=$targetbase;
    $bebebase=~ s|filtered/?$||;
    my $base= Chj::Maildir::Basefolder->new($bebebase);

    sub writewarnmail {
	my ($subj,$data)=@_;
	my $mail = EL::Util::Sendmail::prepare_mailasstring(To=>"you",
							    From=>"$myname",
							    Subject=>"$subj",
							    Data=>"$data");
	my $warnfile = xtmpfile Chj::IO::Tempfile "$bebebase/tmp/";
	$warnfile->xprint($mail);
	$warnfile->xclose;
	$base->deliver_file($warnfile->path);
	#xlink $warnfile->path,"$targetbase/inbox" AH ich wollte das nöd weil : hrre filename generierung.
    }
}


sub conditional_move_file($ $ ) {
    my ($filepath,$targetbase)=@_;#(funny, dass ich $targetbase hier explizit übergebe "um unanständige globals" nicht zu benutzen.)
    $filepath= do {
	#untaint it. just trust it, it's coming from readdir or from arguments.
	$filepath=~ m|(.*)|s;
	$1;
    };
    my $filename=$filepath; $filename=~ s{^.*/}{}s;

    my $quotedsubject="(abgebrochen bevor subject geholt)";
    my $from;
    my $quotedfrom;
    my $quotedfoldername;
    $quotedfrom=$quotedfoldername="(abgebrochen bevor geholt)";
    eval {
	my ($mail,$foldername,$type,$important)= analyze_file $filepath;  #(man sieht es fast nicht..)
	$quotedsubject= singlequote($mail->decodedheader("subject"),"(kein subject)");
	#$from=$mail->header("From");
	$from=$mail->decodedheader("From");
	$quotedfrom= singlequote $from;
	$quotedfoldername= singlequote $foldername;

	my $targetfolder_is_symlink;
	if ($foldername) {
	    $foldername=~ s{/}{--}sg;#!wichtig!.. nochmals.
	    $foldername= "dot.$foldername" if $foldername=~ /^\./;#cj 2.8.04, auch noch relevant.

	    # und, ganz wichtig ha:
	    $foldername= $truncator->trunc($foldername);

	    my $targetfolder= "$targetbase/$foldername";
	    if (! -d $targetfolder) {
		xmkdir $targetfolder;
		warn "created new folder '$targetfolder'\n";# vielleicht in subject schreiben besser!!todo.
	    }else {
		$targetfolder_is_symlink= readlink $targetfolder ;# or do{ $!== E.... or..
	    }

	    #warn "tainted" if tainted $targetfolder;# is ok
	    warn "tainted" if tainted $filename;
	    my $targetpath= "$targetfolder/$filename";
	    xlinkunlink($filepath,$targetpath);
	    warn "moved '$filename' to '$targetpath'\n" if $verbose;
	} else {
	    warn "'$filename' not moved\n" if $verbose;
	}

	# aha und nun noch die dinger, warnmeldungen und so und dass inreplytoeigenemail.

	# Replydings immer machen wenn es "zu filtern ist und zwar nicht in type inbox". Dann ist es nämlich nicht direkt an mich addressiert.  Und das ist egal ob die box dann symlinked ist (oder  type gleich aber  xyz)
	my $already_warned;
	if ($type ne 'inbox'
	    #and not ($targetfolder_is_symlink
	    #	     and $targetfolder_is_symlink=~ /(?:inbox|new)/) # also wenn ichs eh in die inbox krieg, nix mehr dazu sagen eben. schlau?
	   ) {
	    if ($from) {
		if ($from=~ /christian\.jaeger\@/ or $from=~ /christian\@jaeger\./
		    or $from=~ /christian.*pflanze/ ) {
		    save_is_own($mail);
		}
		elsif (is_reply($mail)){
		    writewarnmail("Antwort: $quotedsubject",
				  "Antwort auf deinen thread,\n".
				  "     From $quotedfrom\n".
				  "  Subject $quotedsubject\n".
				  "in folder $quotedfoldername eingetroffen.\n");
		    $already_warned=1;#leicht murksig
		}
	    }
	}
	if ($important and !$already_warned){
	    writewarnmail(($foldername=~/inbox-big/ ? "Big":"Wichtig").": $quotedsubject",
			  "Email mit\n".
			  "     From $quotedfrom\n".
			  "  Subject $quotedsubject\n".
			  "in folder $quotedfoldername eingetroffen.\n");
	}

	# autoreply senden:
	if ($do_send_autoreply) {
	    #if ($type eq 'inbox') { ach, Cron mails und solches isch dann auch dabei.
	    if ($foldername eq 'inbox' or $foldername eq 'inbox-big') {
		# can we be sure that hier kein email hin kommt das bulk header hat, zB selber ne autoreply isch?.
		# nein: wenn es keine der %known_list_precedences ist (well wär mir egal), oder resent-from fehlt und nicht sender owner-xyz dings isch, dann würde es nid gefiltert werden obwohl es precedence header hat. also hier explizit checken:
		if (do{# bulkiges email
		    #if (my $precedence= chompspace($mail->header("precedence"))) {##ps erscht hier mach ich chompspace, in mailmoverlib nicht!!  EHR das mach ich bei headers EH.  hatt ich das nich schon als unschön taxiert.   ACH und dann auch noch undef Fall.
		    if (my $precedence= $mail->header("precedence")) {
			#if (exists $MailHead::known_list_precedences{$precedence}) { eh isch dort lexical.
			if (lc($precedence) eq 'bulk'
			    or
			    lc($precedence) eq 'list'){
			    1
			} elsif (lc($precedence) eq 'junk') {#nöd = !
			    1
			} else {
			    0
			}
		    } else {
			0
		    }
		}) {
		    #warn "not filtered but still bulkiges email";
		} else {
		    # und ehrlich kein autoreply?
		    unless ($mail->lookslike_autoreply) {
			unless (do {
			    if (defined(my $spamhits=$mail->spamhits)) {
				$spamhits >= 0.5
			    } else {
				#(huh, ein mail ohne spamhits angabe?)
				undef
			    }
			}) {
			    my $senderaddress= $mail->decodedheader("from");
			    # ^- aber  extrahieren und so   hab ich doch auch schon gemacht  für sms dings   ah kann einfach volles Teil schicken  mit der EL::Util::Sendmail library 'offenbar'.
			    autoreply::send_if_not_already($senderaddress,
							   'christian.jaeger@ethlife.ethz.ch',
							   scalar $mail->decodedheader("subject"))
				and warn "sent autoreply\n";
			}
		    }
		}
	    }
	}
    };
    if (!catcherrors) {
	die if ref$@ or $@;
    }
    push @warns, "Error/exception:\n".$@ if $@;

    writewarnmail("warnings for email $quotedsubject",
		  "warnings for email:\n".
		  "     From $quotedfrom\n".
		  "  Subject $quotedsubject\n".
		  "put to folder $quotedfoldername\n".
		  join "\n",@warns) if @warns;
    @warns=();#!!!!!!!!!!!!!!!!
}

# main:

$|=1;

usage "only one source dir argument allowed" if $sourcedir and @args;

if ($sourcedir) {
    DO: {
	my $d= xopendir $sourcedir;
	while(defined(my$item=$d->xnread)){
	    conditional_move_file("$sourcedir/$item",$targetbase);
	}
	if ($opt_loop) {
	    sleep $opt_loop;
	    print STDERR "$myname: redoiing\n" if $DEBUG;
	    if (defined $opt_repeat) {
		redo DO if --$opt_repeat;
	    } else {
		redo DO
	    }
	}
    }
}
elsif (@args) {
    for my $filepath (@args) {
	conditional_move_file($filepath,$targetbase);
    }
}
else {
    usage "no source dir or files given";
}
