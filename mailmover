#!/usr/bin/perl -wT

#
# Copyright 2007-2015 by Christian Jaeger, ch at christianjaeger ch
# Published under the same terms as perl itself
#
(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

# NOTES:
# - "sourceforge" subject clipping code is only active when delivering to maildir.

use strict; use warnings FATAL => 'uninitialized';

use constant DEBUG=> ($ENV{DEBUG} ? 1 : 0); # conditional needed for detainting

use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/lib";

use findfunctionalperl;

use Carp;
use Chj::Backtrace;
use Chj::WithRepl qw(push_withrepl WithRepl_eval);
push_withrepl (0) if DEBUG;
use Scalar::Util 'tainted';
use Chj::xopendir;
use Chj::xperlfunc ':all';
use Chj::xtmpfile;
use Chj::singlequote;
use Chj::chompspace;
use Chj::xsysopen 'xsysopen_excl';
use Chj::xopen 'xopen_read';
use FP::IOStream qw(xopendir_pathstream);
use FP::Ops qw(string_cmp);
use Mailmover::MovePath;
use Mailmover::l10n;
use Mailmover::detaint;
$ENV{PATH}= detaint ($ENV{PATH}); # just trust it, it's always under
                                  # our control, isnt't it?

my $do_send_autoreply=0;

use Mailmover::Lib;
#use Mailmover::Autoreply;
#XXX    require "$mydir/mailmover_autoreply.pm"
die "unfinished" if $do_send_autoreply;

use Chj::TransparentNoncachingLazy;

# Read config:
use Mailmover::FirstFoundPath;
use Mailmover::safe_HOME;
my $home= safe_HOME;
require ( xfirst_found_path("$home/.mailmover_config.pl",
			    "./.mailmover_config.pl",
			    "./default_mailmover_config.pl") );
# needs to define is_own_emailaddress, own_emailaddress and
# mailbox_language

$l10n_lang= mailbox_language();


sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname -d sourcedir | -f sourcefile(s)  targetbase

  Options:
  -d|--dir  path      take all files inside sourcedir
  -f|--files  files   take given files
  --stdin             read mail from stdin
  --leave-inbox       xxx
  -l|--loop-every n   keep running: sleep n seconds then scan again.
  --repeat n          only loop n times, then end. (to prevent memoryleaks from becoming awful, or for test runs with Devel::LeakTrace)

  -m|--maildir        work with maildirs, not just plain dirs; this is for
                      the *output* only

  --ham               mail(s) is/are ham, ignore X-Spam-Status headers

  '/filtered' is appended to targetbase to get the real target
  directory if -m option is not given.

  (Christian Jaeger <$email>)
";
exit @_ ? 1 : 0;
}

my @args;
my $DEBUG=0;
my $verbose=0;
my ($sourcedir);
my ($opt_leaveinbox,
    $opt_loop,
    $opt_repeat,
    $opt_is_ham,
    $opt_maildirs,
    $opt_files,
    $opt_stdin);
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
    	usage
    } elsif ($_ eq '--') {
    	push @args, @ARGV[$i+1..$#ARGV];
    	last;
    } elsif (/^--?d(?:dir(?:=(.*))?)?$/) {
        if (defined $1) {
            $sourcedir=$1
        } else {
            $sourcedir=$ARGV[++$i] or usage "missing argument for '$_' option";
        }
    } elsif (/^--?l(?:oop-every(?:=(.*))?)?$/) {
        if (defined $1) {
            $opt_loop=$1
        } else {
            $opt_loop=$ARGV[++$i]
        }
	$opt_loop+=0;
	$opt_loop or usage "missing argument for '$_' option";
    } elsif (/^--?d(ebug)?$/) {
	$DEBUG=1;
    } elsif (/^--leave-inbox$/) {
	$opt_leaveinbox=1;
    } elsif (/^--repeat(?:=(.*))?$/) {
        if (defined $1) {
            $opt_repeat=$1
        } else {
            $opt_repeat=$ARGV[++$i]
        }
	$opt_repeat+=0;
	$opt_repeat or usage "missing argument for '$_' option";
    } elsif (/^--maildirs?$/ or /^-m$/) {
	$opt_maildirs=1;
    } elsif (/^--?(v+)(?:erbose)?$/) {
	$verbose+=length($1);
    } elsif (/^--files$/) {
	$opt_files=1;
    } elsif (/^--stdin$/) {
	$opt_stdin=1;
    } elsif (/^--ham$/) {
	$opt_is_ham=1;
    } elsif (/^-./) {
    	usage("Unknown option '$_'\n");
    } else {
    	push @args, $_
    }
}
usage unless @args;

usage "give exactly one of --stdin / --files / --dir"
  unless (($opt_stdin or $opt_files or $sourcedir) and
	  not (($opt_files and $opt_stdin)
	       or
	       ($opt_files and $sourcedir)
	       or
	       ($opt_stdin and $sourcedir)));

usage "don't give files unless --files is given"
  if (@args > 1 and not $opt_files);

usage "--repeat requires --loop-every" if ($opt_repeat and not $opt_loop);

my $targetbase= do {
    my $p= pop @args;
    # detaint it - trust it.
    $p=~ m|^([^~].*)|s or die "invalid path starting with a tilde: '$p'";
    $1
};
my $targetbase_messages= $targetbase;

our $maildirbasefolder;#only set if in maildir mode
if ($opt_maildirs) {
    require Chj::Maildir::Basefolder;
    require Chj::Maildir::Subfolder;
    $maildirbasefolder= Chj::Maildir::Basefolder->new ($targetbase);
    $maildirbasefolder->create (1);
} else {
    $targetbase = "$targetbase/filtered"; # Hacky, but documented in the usage
}


my @warns;

unless (DEBUG) {
    $SIG{__WARN__}= sub {
	my $msg= join("", @_);
	push @warns,
	  $msg=~ /\n\z/s ? $msg : Carp::longmess($msg);
    };
}

{
    my $base;

    sub writewarnmail {
	my ($subj,$data)=@_;
	eval {
	    require Chj::Sendmail;
	    require Chj::Maildir::Basefolder;
	    1
	} or die "wanted to send mailasstring '$subj' but: $@";
	$base ||= Chj::Maildir::Basefolder->new($targetbase_messages);
	my $mail = Chj::Sendmail::prepare_mailasstring(To=>__("you"),
						       From=>"$myname",
						       Subject=>"$subj",
						       Data=>"$data");
	# Chj::Maildir is still missing 'real' delivery functionality?
	my $warnfile = xtmpfile Chj::IO::Tempfile "$targetbase_messages/tmp/";
	$warnfile->xprint($mail);
	$warnfile->xclose;
	$base->deliver_file($warnfile->path);
    }
}

sub Maybe_take_filename ( $ ) { # take filename iff it is looking like a maildir file
    my ($filepath)=@_;
    $filepath=~ s|.*/||s;
    if ($filepath=~ /^(\d{9,10}\.[^.]+\..*)/s) {
	$1
    } else {
	# (otherwise let the caller let generate a new proper one)
	return
    }
}


sub conditional_move_file($ $ ) {
    my ($filepath,$targetbase)=@_;
    $filepath= detaint $filepath; # coming from readdir or from arguments.

    my $filename=$filepath; $filename=~ s{^.*/}{}s;

    my $quotedsubject= Lazy { "(abgebrochen bevor subject geholt)" };
    my $from;
    my $quotedfrom;
    my $quotedfolderpath;
    $quotedfrom=$quotedfolderpath= Lazy { "(abgebrochen bevor geholt)" };
    WithRepl_eval {
	my ($mail,$folderpath,$type,$important)=
	  analyze_file ($filepath, undef, $opt_is_ham);
	$quotedsubject= Lazy { singlequote($mail->maybe_decoded_header("subject"),
					   "(kein subject)") };
	$from=$mail->maybe_decoded_header("From");
	$quotedfrom= Lazy { singlequote $from };
	$quotedfolderpath= Lazy { singlequote ($folderpath->string ($targetbase)) };

	my $targetfolder_is_symlink;
	if ($folderpath) {
	    if ($opt_maildirs) {
		my $make_sub= sub {
		    my ($folderpath, $flag_sourceforge_original)=@_;
		    if ($folderpath->string($targetbase) eq "inbox"
			#or
			#$folderpath->string($targetbase) eq "inbox-big"
		       ) {
			$maildirbasefolder
		    } else {
			# hacky / should be an option?
			$type="" if $type eq "unbekannt";
			my @perhaps_type= length($type) ? $type : ();
			$folderpath=
			  ($flag_sourceforge_original ?
			   MovePath("Moved", @perhaps_type, "original")
			   : MovePath ("Moved", @perhaps_type)) ->append($folderpath);
			#/hacky
			my @pathparts= $folderpath->string_split($targetbase);
			my $sub= $maildirbasefolder;
			for (@pathparts) {
			    next unless length;
			    $sub= Chj::Maildir::Subfolder->new ($sub,$_);
			}
			$sub->create(1)
			  and warn (__("created new folder:")
				    ." $quotedfolderpath\n");
			# Instead send specialized notification
			# message? But that's bad for testing. Instead
			# detect specially in warning handler?
			$sub
		    }
		};
		my $deliver= sub {
		    my ($filepath,$sub,$maybe_filename)=@_;
		    $sub->deliver_file
		      ($filepath,
		       $maybe_filename || Maybe_take_filename($filepath));
		};
		if ($type eq "sourceforge") {
		    &$deliver($filepath,  &$make_sub($folderpath, 1));

		    # isnt't it HACKY: in mailmoverlib I've got the
		    # head in memory anyway.
		    my $in= xopen_read $filepath;
		    my $t= xtmpfile "$targetbase/tmp/"; # don't forget the end slash
		    my $originator= do {
			my $By;
			while (<$in>) {
			    if (/^$/) {
				for (1..10) {
				    $_=<$in>; last unless defined $_;
				    if (($By)= /^By:\s*(\S+)/) {
					last;
				    }
				}
				last;
			    }
			}
			$By
		    };
		    #warn "originator='$originator'";
		    $in->xrewind;
		    while (<$in>) {
			if (/^$/) {
			    $t->xprint ($_);
			    while (<$in>) {
				$t->xprint ($_);
			    }
			    last;
			} else {
			    (s/^(subject:\s*)\[[^\]]+\]\s*(.*)/$1$2/si
			     or
			     s/^(from:\s*)(.*)/
				 my ($pre,$adr)=($1,$2);
				 if ($originator) {
				     $adr=~ s{"[^\"]*"}{"$originator"};
				 }
				 $pre.$adr
			     /ei);
			    $t->xprint ($_);
			}
		    }
		    $in->xclose;
		    $t->xclose;
		    &$deliver($t->path,
			      &$make_sub($folderpath, 0),
			      Maybe_take_filename($filepath));
		} else {
		    &$deliver($filepath,
			      &$make_sub($folderpath, 0));
		}
		xunlink $filepath;
	    } else {
		my $targetfolder= $targetbase . "/" . $folderpath->string($targetbase);
		if (! -d $targetfolder) {
		    xmkdir $targetfolder;
		    warn __("created new folder:")." '$targetfolder'\n";
		    # better write special email? But that's bad for
		    # testing.
		} else {
		    $targetfolder_is_symlink= readlink $targetfolder;
		    # or do{ $!== E.... or..
		}

		#warn "tainted" if tainted $targetfolder;# is ok
		warn "tainted" if tainted $filename;
		my $targetpath= "$targetfolder/$filename";
		xlinkunlink($filepath,$targetpath);
		warn "moved '$filename' to '$targetpath'\n" if $verbose;
	    }
	} else {
	    warn "'$filename' not moved\n" if $verbose;
	}

	# Notifications about replies to own filtered email (hence the
	# replies will likely be filtered too):

	my $already_warned;
	if ($type ne 'inbox') {
	    if ($from) {
		if (is_own_emailaddress($from)) {
		    save_is_own($mail);
		} elsif (is_reply($mail)){
		    writewarnmail(__("Reply").": $quotedsubject",
				  __("A followup to your email")."\n".
				  __("     From")." $quotedfrom\n".
				  __("  Subject")." $quotedsubject\n".
				  __("has arrived in folder ").$quotedfolderpath
				  .__(" eingetroffen").".\n");
		    $already_warned=1;
		}
	    }
	}
	if ($important and !$already_warned){
	    writewarnmail
	      (($folderpath->string($targetbase)=~/inbox-big/ ?
		__("Big") : __("Important"))
	       .": $quotedsubject",

	       __("Email mit\n").
	       __("     From")." $quotedfrom\n".
	       __("  Subject")." $quotedsubject\n".
	       __("has arrived in folder ").$quotedfolderpath
	       .__(" eingetroffen").".\n");
	}

	# send autoreply:

	if ($do_send_autoreply) {
	    # $type eq 'inbox' is not enough, includes Cron mails? or similar.
	    # XX what is $type really for now?
	    my $str= $folderpath->string($targetbase);
	    if ($str eq 'inbox' or $str eq 'inbox-big') {
		# Can we be sure that no mail with bulk header
		# (autoreplies etc.) makes it here? No, if it isn't
		# any of the %known_list_precedences (well
		# irrelevant?), or resent-from is missing and isn't
		# sender owner-xyz then it would not be filtered even
		# though it has precedence header. Thus check
		# explicitely here:
		if (do {
		    if (my $precedence= $mail->maybe_header("precedence")) {
			$precedence= lc $precedence;
			if ($precedence eq 'bulk'
			    or
			    $precedence eq 'list') {
			    1
			} elsif ($precedence eq 'junk') {
			    1
			} else {
			    0
			}
		    } else {
			0
		    }
		}) {
		    #warn "not filtered but still bulky email";
		} else {
		    # really not an autoreply?
		    unless ($mail->is_autoreply) {
			unless (do {
			    if (defined(my $maybe_spamscore=$mail->maybe_spamscore)) {
				$maybe_spamscore >= 0.5
			    } else {
				#(huh, a mail without spamscore?)
				undef
			    }
			}) {
			    my $senderaddress= $mail->maybe_decoded_header("from");
			    # ^- but didn't I do extraction for sms already?
			    autoreply::send_if_not_already
				($senderaddress,
				 own_emailaddress (),
				 scalar $mail->maybe_decoded_header("subject"))
				  and warn __("sent autoreply")."\n";
			}
		    }
		}
	    }
	}
	1
    } || do {
	if (DEBUG) {
	    die $@
	}
    };
    push @warns, __("Error/exception:\n").$@ if $@;

    if (@warns) {
	writewarnmail(__("Warnings for email")." $quotedsubject",
		      __("Warnings for email").":\n".
		      __("     From")." $quotedfrom\n".
		      __("  Subject")." $quotedsubject\n".
		      __("saved in folder")." $quotedfolderpath:\n\n".
		      join "\n\n",@warns);
	@warns=(); # !
    }
}

# main:

$|=1;

usage "only one source dir argument allowed"
  if $sourcedir and @args;

if ($sourcedir) {
  DO: {
	xopendir_pathstream ($sourcedir, *string_cmp)->for_each
	  (sub { conditional_move_file($_[0],$targetbase) });
	if ($opt_loop) {
	    sleep $opt_loop;
	    print STDERR "$myname: redoiing\n" if $DEBUG;
	    if (defined $opt_repeat) {
		redo DO if --$opt_repeat;
	    } else {
		redo DO
	    }
	}
    }
}
elsif ($opt_files) {
    for my $filepath (@args) {
	conditional_move_file($filepath,$targetbase);
    }
}
elsif ($opt_stdin) {
    if ($opt_maildirs) {
	my $path= "$targetbase/tmp/".$maildirbasefolder->create_filename;
	WithRepl_eval {
	    my $t= xsysopen_excl $path, 0600;
	    my $in= bless *STDIN{IO},"Chj::IO::File";
	    $in->xsendfile_to($t);
	    $in->xclose;
	    $t->xflush; # must flush before sync.
	    # XX add to Chj::IO::File ?
	    require IO::Handle;
	    IO::Handle::sync ($t) or die "IO::Handle::sync: $!";
	    $t->xclose; # (must remain open for sync call)
	    conditional_move_file ($path,$targetbase);
	    1
	} || do {
	    my $e=$@;
	    unlink $path; # sort of tmpfile functionality recovery
	    die $e
	};
    } else {
	die "delivery from stdin only implemented for --maildirs"
    }
}
else {
    die "bug" # should have been trapped earlier
}
